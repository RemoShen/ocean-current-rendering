<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
    <style type="text/css">
      html,
      body {
        margin: 0;
        height: 100%;
        width: 100%;
      }

      canvas {
        display: block;
      }
    </style>
  </head>
  <body onload="draw();"></body>
  <script src="https://www.wjceo.com/lib/three.js"></script>
  <script src="https://www.wjceo.com/lib/js/loaders/VTKLoader.js"></script>
  <script src="https://www.wjceo.com/lib/js/controls/OrbitControls.js"></script>
  <script src="https://www.wjceo.com/lib/js/libs/stats.min.js"></script>
  <script src="https://www.wjceo.com/lib/js/libs/dat.gui.min.js"></script>

  <script>
    var renderer;
    function initRender() {
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xffffff);
      document.body.appendChild(renderer.domElement);
    }
    var camera;
    function initCamera() {
      camera = new THREE.PerspectiveCamera(
        45,
        window.innerWidth / window.innerHeight,
        1,
        1000
      );
      camera.position.set(0, 0, 0);
      camera.lookAt(new THREE.Vector3(0, 0, 0));
    }

    var scene;
    function initScene() {
      scene = new THREE.Scene();
    }

    function initGui() {
      var gui = new dat.GUI();
      var dimensions = ["salinity", "temperature", "velocity"];
      gui
        .add({ Dimension: currentDimension }, "Dimension", dimensions)
        .onChange(function (value) {
          updateModelColor(value);
        });
    }

    var light;
    function initLight() {
      scene.add(new THREE.AmbientLight(0x444444));
      light = new THREE.PointLight(0xffffff);
      light.position.set(0, 50, 50);
      light.castShadow = true;
      scene.add(light);
    }

    var currentDimension = "temperature";
    var modelData;
    function initModel() {
      var helper = new THREE.AxesHelper(50);
      scene.add(helper);

      var loader = new THREE.FileLoader();
      loader.load("./public/ocean_data.json", function (jsonStr) {
        modelData = JSON.parse(jsonStr);
        createModelGeometry(modelData);
      });
    }
    var geometry = new THREE.BufferGeometry();
    var currentPoints;
    function createModelGeometry(modelData) {
      var points = modelData.points;
      var salinity = modelData.salinity;
      var temperature = modelData.temperature;
      var velocity = vectorLength(modelData.velocity);
      var positions = new Float32Array(points.length * 3);
      var colors = new Float32Array(points.length * 3);
      var color = new THREE.Color();

      var minSalinity = calculateDataRange(salinity).min;
      var maxSalinity = calculateDataRange(salinity).max;
      var minTemperature = calculateDataRange(temperature).min;
      var maxTemperature = calculateDataRange(temperature).max;
      var minVelocity = calculateDataRange(velocity).min;
      var maxVelocity = calculateDataRange(velocity).max;
      //caculate center point
      var center = [0, 0, 0];
      for (var i = 0; i < points.length; i++) {
        center[0] += points[i][0];
        center[1] += points[i][1];
        center[2] += points[i][2];
      }
      center[0] /= points.length;
      center[1] /= points.length;
      center[2] /= points.length;
      for (var i = 0, j = 0; i < points.length; i++, j += 3) {
        var point = points[i];
        positions[j] = point[0] - center[0];
        positions[j + 1] = point[1] - center[1];
        positions[j + 2] = point[2] - center[2];

        var value = getSelectedDimensionValue(
          i,
          minSalinity,
          maxSalinity,
          minTemperature,
          maxTemperature,
          minVelocity,
          maxVelocity,
          salinity,
          temperature,
          velocity
        );
        color.setRGB(value, 0, 1 - value); // interpolate between blue and red based on the value
        colors[j] = color.r;
        colors[j + 1] = color.g;
        colors[j + 2] = color.b;
      }

      geometry.addAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      geometry.addAttribute(
        "color",
        new THREE.Float32BufferAttribute(colors, 3)
      );

      var material = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: THREE.VertexColors,
      });

      var mesh = new THREE.Points(geometry, material);
      scene.add(mesh);
      currentPoints = mesh;

      boundingBox = new THREE.Box3();
      boundingBox.setFromObject(mesh);

      var maxAxisSize = Math.max(
        boundingBox.max.x - boundingBox.min.x,
        boundingBox.max.y - boundingBox.min.y,
        boundingBox.max.z - boundingBox.min.z
      );
      var maxDistance =
        maxAxisSize / Math.tan((camera.fov / 2) * (Math.PI / 180));
      camera.position.set(0, 0, maxDistance * 1.5);
      camera.updateProjectionMatrix();
    }

    function vectorLength(vector) {
      var length = [];
      for (var i = 0; i < vector.length; i++) {
        length.push(
          Math.sqrt(
            vector[i][0] * vector[i][0] +
              vector[i][1] * vector[i][1] +
              vector[i][2] * vector[i][2]
          )
        );
      }
      return length;
    }
    function getSelectedDimensionValue(
      index,
      minSalinity,
      maxSalinity,
      minTemperature,
      maxTemperature,
      minVelocity,
      maxVelocity,
      salinity,
      temperature,
      velocity
    ) {
      if (currentDimension === "salinity") {
        return (salinity[index] - minSalinity) / (maxSalinity - minSalinity);
      } else if (currentDimension === "temperature") {
        return (
          (temperature[index] - minTemperature) /
          (maxTemperature - minTemperature)
        );
      } else if (currentDimension === "velocity") {
        return (velocity[index] - minVelocity) / (maxVelocity - minVelocity);
      }
    }

    function calculateDataRange(values) {
      var min = Infinity;
      var max = -Infinity;
      for (var i = 0; i < values.length; i++) {
        if (values[i] < min) min = values[i];
        if (values[i] > max) max = values[i];
      }
      return {
        min: min,
        max: max,
      };
    }

    var stats;
    function initStats() {
      stats = new Stats();
      document.body.appendChild(stats.dom);
    }

    var controls;
    function initControls() {
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      //controls.addEventListener( 'change', render );
      controls.enableDamping = true;
      controls.dampingFactor = 0.25;
      controls.enableZoom = true;
      controls.autoRotate = false;
      controls.autoRotateSpeed = 0.5;
      controls.minDistance = 1;
      controls.maxDistance = 200;
      controls.enablePan = true;
    }

    function updateModelColor(dimension) {
      currentDimension = dimension;
      var updateData;
      if (dimension === "velocity") {
        updateData = vectorLength(modelData.velocity);
      } else {
        updateData = modelData[dimension];
      }
      var updateDAtaMin = calculateDataRange(updateData).min;
      var updateDataMax = calculateDataRange(updateData).max;
      console.log(updateDAtaMin, updateDataMax);
      var colors = [];
      var color = new THREE.Color();

      for (var i = 0; i < modelData.points.length; i++) {
        var value = updateData[i];
        var normalizedValue =
          (value - updateDAtaMin) / (updateDataMax - updateDAtaMin);

        const hi = [180 / 255, 6 / 255, 38 / 255];
        const mi = [218 / 255, 220 / 255, 223 / 255];
        const lo = [60 / 255, 78 / 255, 194 / 255];
        if (normalizedValue > 0.5) {
          normalizedValue = 1 - (normalizedValue - 0.5) * 2;
          color.setRGB(
            hi[0] * (1 - normalizedValue) + mi[0] * normalizedValue,
            hi[1] * (1 - normalizedValue) + mi[1] * normalizedValue,
            hi[2] * (1 - normalizedValue) + mi[2] * normalizedValue
          );
        } else {
          normalizedValue = 1 - normalizedValue * 2;
          color.setRGB(
            mi[0] * (1 - normalizedValue) + lo[0] * normalizedValue,
            mi[1] * (1 - normalizedValue) + lo[1] * normalizedValue,
            mi[2] * (1 - normalizedValue) + lo[2] * normalizedValue
          );
        }
        colors.push(color.r, color.g, color.b);
        // colors.push(180 / 255, 22 / 255,  5 / 255);
      }

      geometry.addAttribute(
        "color",
        new THREE.Float32BufferAttribute(colors, 3)
      );
      var material = new THREE.PointsMaterial({
        size: 0.5,
        vertexColors: THREE.VertexColors,
      });
      var points = new THREE.Points(geometry, material);
      scene.add(points);
      if (currentPoints) {
        scene.remove(currentPoints);
        currentPoints.geometry.dispose();
        currentPoints.material.dispose();
      }
      currentPoints = points;
      render();
    }

    function render() {
      renderer.render(scene, camera);
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      render();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      render();
      stats.update();
      controls.update();
      requestAnimationFrame(animate);
    }

    function draw() {
      initGui();
      initRender();
      initScene();
      initCamera();
      initLight();
      initModel();
      initControls();
      initStats();
      animate();
      window.onresize = onWindowResize;
    }
  </script>
</html>
